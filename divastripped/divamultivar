#!/bin/bash

# method = 1 put regression into single data misfit
method=1

valex=-9999

if [ "$#" -le "0" ]
then
echo ????????????????????????????????????????????
echo usage: divamultivar intensity  [niterations]
echo ????????????????????????????????????????????
exit
fi

intensity=$1

rm ./output/reg*.dat.0?

echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
echo  Multivariate approach on two files
echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

echo need to modify param.par for iterations to desactivate error calculations

cp -v ./input/param.par.01 ./input/param.multivar.par.01
cp -v ./input/param.par.02 ./input/param.multivar.par.02
#cp -v ./input/data.dat.01 ./input/data.multivar.dat.01
#cp -v ./input/data.dat.02 ./input/data.multivar.dat.02

awk '{ if (NF==3) {print $1,$2,$3,1} else { print $0 } }' ./input/data.dat.01 > ./input/data.multivar.dat.01
awk '{ if (NF==3) {print $1,$2,$3,1} else { print $0 } }' ./input/data.dat.02 > ./input/data.multivar.dat.02

echo Will now scale data so as to have similar variances

awk '{mean+=$3;var+=$3*$3;i+=1} END { print mean/i,sqrt(var/i-(mean/i)*(mean/i))}' ./input/data.dat.01 > varian.01
awk '{mean+=$3;var+=$3*$3;i+=1} END { print mean/i,sqrt(var/i-(mean/i)*(mean/i))}' ./input/data.dat.02 > varian.02

echo will scale data by respective input data standard deviation 
echo If other scaling, adapt varian.xx files

awk 'NR==FNR {a=$1;b=$2} {if (NR!=FNR) {$3=($3-a)/b ; if (NF==3) {print $1,$2,$3,1} else { print $0 } }}' varian.01 ./input/data.dat.01 > ./input/data.multivar.dat.01
awk 'NR==FNR {a=$1;b=$2} {if (NR!=FNR) {$3=($3-a)/b ; if (NF==3) {print $1,$2,$3,1} else { print $0 } }}' varian.02 ./input/data.dat.02 > ./input/data.multivar.dat.02


rm -f ./input/pseudodata.dat.01
rm -f ./input/pseudodata.dat.02

if [ "$method" == "1" ]
then
echo Initial pseudo data are real data
cp -v ./input/data.multivar.dat.01 ./input/pseudodata.dat.01
cp -v ./input/data.multivar.dat.02 ./input/pseudodata.dat.02
fi

echo need to think about valatxy.coord

echo use now $valex as exclusion value

head -17 ./input/param.multivar.par.01 > bidon
echo 1 >> bidon
echo   >> bidon
echo 1 >> bidon
echo   >> bidon
echo $valex >> bidon
echo >> bidon
head -24 ./input/param.multivar.par.01 | tail -1 >> bidon
echo >> bidon
echo 0 >> bidon
mv bidon ./input/param.par.01

head -17 ./input/param.multivar.par.02 > bidon
echo 1 >> bidon
echo   >> bidon
echo 1 >> bidon
echo   >> bidon
echo $valex >> bidon
echo >> bidon
head -24 ./input/param.multivar.par.02 | tail -1 >> bidon
echo >> bidon
echo 0 >> bidon
mv bidon ./input/param.par.02


nsteps=10



if [ "$#" -gt "1" ]
then
let nsteps=$2+0
fi
echo =============================================
echo Number of iterations to be performed: $nsteps
echo =============================================


i=0

while [ "$i" -le "$nsteps" ]
do
let i=$i+1
echo Iteration $i

# 


if [ "$i" -gt "$nsteps" ]
then
echo Last final analysis

head -21 ./input/param.multivar.par.01 > bidon
echo $valex >> bidon
head -26 ./input/param.multivar.par.01 | tail -4 >> bidon
mv bidon ./input/param.par.01


head -21 ./input/param.multivar.par.02 > bidon
echo $valex >> bidon
head -26 ./input/param.multivar.par.02 | tail -4 >> bidon
mv bidon ./input/param.par.02


rm -f ./input/param.multivar.par.01


rm -f ./input/param.multivar.par.02

fi

echo FIELD 1

if [ "$method" == "1" ]
then
echo only pseudo-data
cat ./input/pseudodata.dat.01 > ./input/data.dat
else
cat ./input/data.multivar.dat.01 > ./input/data.dat
cat ./input/pseudodata.dat.01 >> ./input/data.dat
fi
cp -v ./input/param.par.01 ./input/param.par
cp -v ./input/data.multivar.dat.02 ./input/valatxy.coord
echo mesh only on first iteration 
if [ "$i" -le "1" ] 
then
divamesh
fi
divacalc

echo Save analyses 
cp -v ./output/valatxyascii.anl ./input/valxy.01
cp -v ./output/fieldgher.anl ./output/fieldgher.anl.01
cp -v ./output/fieldatdatapoint.anl ./output/fieldatdatapoint.anl.01
cp -v ./output/errorfieldgher.anl ./output/errorfieldgher.anl.01




echo FIELD 2
if [ "$method" == "1" ]
then
echo only pseudo-data
cat ./input/pseudodata.dat.02 > ./input/data.dat
else
cat ./input/data.multivar.dat.02 > ./input/data.dat
cat ./input/pseudodata.dat.02 >> ./input/data.dat
fi
cp -v ./input/param.par.02 ./input/param.par
cp -v ./input/data.multivar.dat.01 ./input/valatxy.coord

divamesh
divacalc

echo Save analyses 
cp -v ./output/valatxyascii.anl ./input/valxy.02
cp -v ./output/fieldgher.anl ./output/fieldgher.anl.02
cp -v ./output/fieldatdatapoint.anl ./output/fieldatdatapoint.anl.02
cp -v ./output/errorfieldgher.anl ./output/errorfieldgher.anl.02


if [ "$method" == "1" ]
then
echo Now pseudo data method $method

# fit between residual and analayses of other field

rm -f residue.dat.01
rm -f residue.dat.02
ldat=$(cat ./input/data.multivar.dat.01 | wc -l)
head -$ldat ./output/fieldatdatapoint.anl.01 > biddddon
awk '{print $1,$2,$3,$4}' ./input/data.multivar.dat.01 > bidddon
paste bidddon biddddon | awk '{ print $1,$2, $3-$7,$4}' > residue.dat.01
ldat=$(cat ./input/data.multivar.dat.02 | wc -l)
awk '{print $1,$2,$3,$4}' ./input/data.multivar.dat.01 > bidddon
head -$ldat ./output/fieldatdatapoint.anl.02 > biddddon
paste bidddon biddddon | awk '{ print $1,$2, $3-$7,$4}' > residue.dat.02
paste ./input/valxy.02 residue.dat.01 | awk -v valex=$valex '{ if ($3 != valex) print $3,$6}' > psi2d1.dat
paste ./input/valxy.01 residue.dat.02 | awk -v valex=$valex '{ if ($3 != valex) print $3,$6}' > psi1d2.dat





cat psi2d1.dat > biddon
cat biddon | awk -f "dvlinreg.awk" > ./output/regression.dat.01
rm -f biddon

cat psi1d2.dat > biddon
cat biddon | awk -f "dvlinreg.awk" > ./output/regression.dat.02
rm -f biddon
cat ./output/regression.dat.01 >> ./output/reg.dat.01
cat ./output/regression.dat.02 >> ./output/reg.dat.02


echo Now, from the regression, create pseudo-data
awk '{print $1,$2,$3,$4}' ./input/data.multivar.dat.01 > bidddon
paste bidddon ./input/valxy.02 > biddon
awk 'NR==FNR {a=$1;b=$2;w=$3} {if (NR!=FNR) print $1,$2,$3-a*$7-b,$4}' ./output/regression.dat.01 biddon > ./input/pseudodata.dat.01
awk '{print $1,$2,$3,$4}' ./input/data.multivar.dat.02 > bidddon
paste bidddon ./input/valxy.01 > biddon
awk 'NR==FNR {a=$1;b=$2;w=$3} {if (NR!=FNR) print $1,$2,$3-a*$7-b,$4}' ./output/regression.dat.02 biddon > ./input/pseudodata.dat.02

echo need to add pseudo data in other locations too
ldat=$(cat ./input/data.multivar.dat.02 | wc -l)
head -$ldat ./output/fieldatdatapoint.anl.02 > bidddon
awk '{print $1,$2,$3,$4}' ./input/data.multivar.dat.02 > bidddddon
paste bidddddon bidddon > biddon
awk 'NR==FNR {a=$1;b=$2;w=$3} {if (NR!=FNR) print $1,$2,($3-$7-b)/a,$4*a*a}' ./output/regression.dat.02 biddon >> ./input/pseudodata.dat.01
ldat=$(cat ./input/data.multivar.dat.01 | wc -l)
head -$ldat ./output/fieldatdatapoint.anl.01 > bidddon
awk '{print $1,$2,$3,$4}' ./input/data.multivar.dat.01 > bidddddon
paste bidddddon bidddon > biddon
awk 'NR==FNR {a=$1;b=$2;w=$3} {if (NR!=FNR) print $1,$2,($3-$7-b)/a,$4*a*a}' ./output/regression.dat.01 biddon >> ./input/pseudodata.dat.02



else
echo Now pseudo data method $method
echo with treatment of valex
# awk -v valex=$valex '{ if ($3 != valex) print $0}' ./output/valatxyascii.anl > ./input/valxy.01

echo valxy.02 is field 2 at data points 1 and can use valex there

# fit between analysis (use only real data points)
ldat=$(cat ./input/data.multivar.dat.01 | wc -l)
head -$ldat ./output/fieldatdatapoint.anl.01 > bidddon

paste ./input/valxy.02 bidddon | awk -v valex=$valex '{ if ($3 != valex) print $6,$3}' > psi2d1.dat

ldat=$(cat ./input/data.multivar.dat.02 | wc -l)
head -$ldat ./output/fieldatdatapoint.anl.02 > bidddon
paste ./input/valxy.01 bidddon | awk -v valex=$valex '{ if ($3 != valex) print $6,$3}' > psi1d2.dat





cat psi2d1.dat > biddon
# add symmetric data or not
cat psi1d2.dat | awk '{print $2,$1}' >> biddon
cat biddon | awk -f "dvlinreg.awk" > ./output/regression.dat.01
rm -f biddon

cat psi1d2.dat > biddon
# add symmetric data or not
cat psi2d1.dat | awk '{print $2,$1}' >> biddon
cat biddon | awk -f "dvlinreg.awk" > ./output/regression.dat.02
rm -f biddon
cat ./output/regression.dat.01 >> ./output/reg.dat.01
cat ./output/regression.dat.02 >> ./output/reg.dat.02


echo Now, from the regression, create pseudo-data

awk 'NR==FNR {a=$1;b=$2;w=$3} {if (NR!=FNR) print $1,$2,a*$3+b,w}' ./output/regression.dat.01 ./input/data.multivar.dat.01 > ./input/pseudodata.dat.02
awk 'NR==FNR {a=$1;b=$2;w=$3} {if (NR!=FNR) print $1,$2,a*$3+b,w}' ./output/regression.dat.02 ./input/data.multivar.dat.02 > ./input/pseudodata.dat.01


fi

echo now pseudo data are ready


done


if [ "$method" == "1" ]
then
head -1 ./output/regression.dat.01 > ./divawork/fort.20
head -1 ./output/regression.dat.02 >> ./divawork/fort.20
else
echo 1 0 > ./divawork/fort.20
echo 1 0 >> ./divawork/fort.20
fi

if [ "$nsteps" -ge "1" ]
then
echo Now creating final analysis by adding two fields
cp ./output/fieldgher.anl.01 ./divawork/fort.10
cp ./output/fieldgher.anl.02 ./divawork/fort.11

head -1 varian.01 >> ./divawork/fort.20
head -1 varian.02 >> ./divawork/fort.20
cd divawork
../../bin/lincom.a
cp -v fort.12 ../output/fieldgher.anl.01
cp -v fort.13 ../output/fieldgher.anl.02
cd ..
fi




echo ' '
echo ----------------------
echo Multivar is finished
echo ----------------------








